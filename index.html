<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>ws</title>
    <style>
      html, body, #three {
        margin: 0px;
        padding: 0px;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0px;
        left: 0px;
        overflow: hidden;
      }
      b {
        font-size: 16px;
      }
       #description, #link, #actions, #parameters {
         position: absolute;
         z-index: 2;
         font-family: sans-serif;
         border-radius: 5px;
       }
       #parameters {
         left: 20px;
         top: 100px;
         padding: 10px;
         background: white;
         border: 1px solid black;
       }
       #description {
         left: 20px;
         top: 20px;
         padding: 10px;
         background: white;
         border: 1px solid black;
       }
       p {
         padding: 0px;
         margin: 0px;
       }
       p > b {
         font-size: 14px;
       }
       #link {
         left: 20px;
         bottom: 20px;
         padding: 10px;
         background: white;
         border: 1px solid black;
         text-decoration: none;
       }
    </style>
  </head>
  <body>
    <div id="description">
      <b>Shallow Water Equation Demo</b><br>
      (Click the pool)
      <button id="reset-button">Click me to reset</button>
    </div>
    </div>
    <div id="link"><a href="https://github.com/vuoriov4/shape-matching-demo">Source code</a></div>
    <script id="srtVertexShader" type="x-shader/x-vertex">
      varying vec2 texCoord;
      uniform vec2 resolution;
      void main()	{
        texCoord = uv; // 0.5 + position.xy / resolution;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>
    <script id="srtFragmentShader" type="x-shader/x-fragment">
      varying vec2 texCoord;
      uniform sampler2D simulationData;
      uniform float FRAME;
      uniform float T;
      uniform float DT;
      uniform float XMIN;
      uniform float XMAX;
      uniform float YMIN;
      uniform float YMAX;
      uniform float ZMIN;
      uniform float ZMAX;
      uniform float WIDTH_SEGMENTS;
      uniform float HEIGHT_SEGMENTS;
      uniform float MOUSE_DOWN;
      uniform vec2 MOUSE_POSITION;
      uniform float dx;
      uniform float dz;
      vec4 difference(vec4 current, vec2 texCoord, vec2 base, float h) {
        vec2 tx = vec2(h / (XMAX - XMIN), h / (ZMAX - ZMIN));
        vec4 boundary;
        if (dot(base, texCoord - tx) < 0.0) {
          boundary = texture2D(simulationData, texCoord + base * tx);
          boundary.g *= base.x >= 1.0 ? -1.0 : 1.0;
          boundary.b *= base.y >= 1.0 ? -1.0 : 1.0;
        } else if (dot(base, texCoord + tx) > 1.0) {
          boundary = texture2D(simulationData, texCoord - base * tx);
          boundary.g *= base.x >= 1.0 ? -1.0 : 1.0;
          boundary.b *= base.y >= 1.0 ? -1.0 : 1.0;
        }
        return (texture2D(simulationData, texCoord + base * tx) - texture2D(simulationData, texCoord - base * tx)) / (2.0*h);
      }
      vec4 difference2(vec4 current, vec2 texCoord, vec2 base, float h) {
        vec2 tx = vec2(h / (XMAX - XMIN), h / (ZMAX - ZMIN));
        vec4 boundary;
        if (dot(base, texCoord - tx) < 0.0) {
          boundary = texture2D(simulationData, texCoord + base * tx);
          boundary.g *= base.x >= 1.0 ? -1.0 : 1.0;
          boundary.b *= base.y >= 1.0 ? -1.0 : 1.0;
        } else if (dot(base, texCoord + tx) > 1.0) {
          boundary = texture2D(simulationData, texCoord - base * tx);
          boundary.g *= base.x >= 1.0 ? -1.0 : 1.0;
          boundary.b *= base.y >= 1.0 ? -1.0 : 1.0;
        }
        return (texture2D(simulationData, texCoord + base * tx) - 2.0 * current +  texture2D(simulationData, texCoord - base * tx)) / (h*h);
      }
      float dhdt(vec4 current, vec2 texCoord, float dx, float dz) {
        vec4 dfx = difference(current, texCoord, vec2(1, 0), dx);
        vec4 dfz = difference(current, texCoord, vec2(0, 1), dz);
        return -(current.r*dfx.g + current.g*dfx.r + current.r*dfz.b + current.b*dfz.r);
      }
      float dudt(vec4 current, vec2 texCoord, float dx, float dz) {
        float viscosity = 0.1;
        float gravity = 5.0;
        float coriolis = 0.0;
        float drag = 0.1;
        vec4 dfx = difference(current, texCoord, vec2(1, 0), dx);
        vec4 dfz = difference(current, texCoord, vec2(0, 1), dz);
        vec4 dfx2 = difference2(current, texCoord, vec2(1, 0), dx);
        vec4 dfz2 = difference2(current, texCoord, vec2(0, 1), dz);
        return viscosity * (dfx2.g + dfz2.g) - current.g * dfx.g - current.b * dfz.g - gravity * dfx.r + coriolis * current.b - drag*current.g;
      }
      float dvdt(vec4 current, vec2 texCoord, float dx, float dz) {
        float viscosity = 0.1;
        float gravity = 5.0;
        float coriolis = 0.0;
        float drag = 0.1;
        vec4 dfx = difference(current, texCoord, vec2(1, 0), dx);
        vec4 dfz = difference(current, texCoord, vec2(0, 1), dz);
        vec4 dfx2 = difference2(current, texCoord, vec2(1, 0), dx);
        vec4 dfz2 = difference2(current, texCoord, vec2(0, 1), dz);
        return viscosity * (dfx2.b + dfz2.b) - current.g * dfx.b - current.b * dfz.b - gravity * dfz.r  - coriolis * current.b - drag*current.b;
      }
      void main()	{
        vec3 color;
        float H = 0.75*(YMIN + YMAX);
        float dx = (XMAX-XMIN)/WIDTH_SEGMENTS;
        float dz = (ZMAX-ZMIN)/HEIGHT_SEGMENTS;
        if (FRAME == 0.0) {
          color = vec3(min(YMAX, max(YMIN, H)), 0, 0);
        } else {
          float len = length(texCoord - MOUSE_POSITION);
          float userInput = MOUSE_DOWN * (YMAX-YMIN) * exp(-256.0 * len * len);
          vec4 current = texture2D(simulationData, texCoord);
          vec4 right =   texture2D(simulationData, texCoord + vec2(1.0/WIDTH_SEGMENTS, 0.0));
          vec4 up =      texture2D(simulationData, texCoord + vec2(0.0, 1.0/HEIGHT_SEGMENTS));
          vec4 left =    texture2D(simulationData, texCoord + vec2(-1.0/WIDTH_SEGMENTS, 0.0));
          vec4 down =    texture2D(simulationData, texCoord + vec2(0.0, -1.0/HEIGHT_SEGMENTS));
          color = vec3(
            // Lax-friedrichs time step / clamping / user deform
            min(YMAX, 0.25 * (right.r + up.r + left.r + down.r) + dhdt(current, texCoord, dx, dz) * DT + userInput * DT),
            // Euler time step (velocity)
            current.g + dudt(current, texCoord, dx, dz) * DT,
            current.b + dvdt(current, texCoord, dx, dz) * DT
          );
        }
        gl_FragColor = vec4(color, 1.0);
      }
    </script>
    <script id="waterVertexShader" type="x-shader/x-vertex">
      uniform sampler2D simulationData;
      uniform float T;
      uniform float DT;
      uniform float XMIN;
      uniform float XMAX;
      uniform float YMIN;
      uniform float YMAX;
      uniform float ZMIN;
      uniform float ZMAX;
      uniform float WIDTH_SEGMENTS;
      uniform float HEIGHT_SEGMENTS;
      varying vec3 vPosition;
      varying vec3 vNormal;
      vec4 difference(vec2 texCoord, vec2 base, float h) {
        vec2 tx = vec2(h / (XMAX - XMIN), h / (ZMAX - ZMIN));
        if (dot(base, texCoord - tx) < 0.0) {
          return (texture2D(simulationData, texCoord + base * tx) - texture2D(simulationData, texCoord)) / h;
        } else if (dot(base, texCoord + tx) > 1.0) {
          return (texture2D(simulationData, texCoord) - texture2D(simulationData, texCoord - base * tx)) / h;
        } else {
          return (texture2D(simulationData, texCoord + base * tx) - texture2D(simulationData, texCoord - base * tx)) / (2.0*h);
        }
      }
      void main()	{
        vec2 texCoord = vec2((position.x - XMIN) / (XMAX - XMIN), (position.z - ZMIN) / (ZMAX - ZMIN));
        vec4 simColor = texture2D(simulationData, texCoord);
        float dx = (XMAX-XMIN)/WIDTH_SEGMENTS;
        float dz = (ZMAX-ZMIN)/HEIGHT_SEGMENTS;
        vec3 n =  normalize(cross(
          normalize(vec3(0, difference(texCoord, vec2(0,1), dz).r, 1)),
          normalize(vec3(1, difference(texCoord, vec2(1,0), dx).r, 0))
        ));
        vNormal = n;
        vec3 p = vec3(position.x, simColor.r, position.z);
        vPosition = p;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
      }
    </script>
    <script id="waterFragmentShader" type="x-shader/x-fragment">
      #define EPSILON 0.001
      uniform vec3 lightDirection;
      uniform sampler2D poolTexture;
      uniform samplerCube cubeTexture;
      uniform float XMIN;
      uniform float XMAX;
      uniform float YMIN;
      uniform float YMAX;
      uniform float ZMIN;
      uniform float ZMAX;
      uniform float T;
      varying vec3 vPosition;
      varying vec3 vNormal;
      struct intersection {
        bool hit;
      	float distance;
      };
      intersection intersect_box(vec3 bmin, vec3 bmax, vec3 ray_origin, vec3 ray_direction) {
        intersection result;
        result.hit = false;
        vec3 dirfrac;
        dirfrac.x = 1.0 / ray_direction.x; // todo: precompute
        dirfrac.y = 1.0 / ray_direction.y; // todo: precompute
        dirfrac.z = 1.0 / ray_direction.z; // todo: precompute
        float t1 = (bmin.x - ray_origin.x)*dirfrac.x;
        float t2 = (bmax.x - ray_origin.x)*dirfrac.x;
        float t3 = (bmin.y - ray_origin.y)*dirfrac.y;
        float t4 = (bmax.y - ray_origin.y)*dirfrac.y;
        float t5 = (bmin.z - ray_origin.z)*dirfrac.z;
        float t6 = (bmax.z - ray_origin.z)*dirfrac.z;
        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us
        if (tmax < 0.0) return result; // miss
        // if tmin > tmax, ray doesn't intersect AABB
        if (tmin > tmax) return result; // miss
        result.hit = true;
        result.distance = tmin;
        return result;
      }
      float light(vec3 normal, vec3 position) {
        // return light intensity at given normal and position
        vec3 dir1 = normalize(vec3(1,0,0));
        vec3 dir2 = normalize(vec3(0,1,0));
        vec3 dir3 = normalize(vec3(0,0,1));
        vec3 dir = normalize(cameraPosition - position);
        return 0.75 + 0.25 * max(0.0, dot(dir, normal));
      }
      vec2 poolTextureCoords(vec3 iPosition) {
        if (iPosition.x < XMIN + EPSILON || iPosition.x > XMAX - EPSILON) {
          return mod(0.5*vec2(ZMAX - iPosition.z, YMAX - iPosition.y), 1.0);
        } else if (iPosition.y < YMIN + EPSILON || iPosition.y > YMAX - EPSILON) {
          return mod(0.5*vec2(ZMAX - iPosition.z, XMAX - iPosition.x), 1.0);
        } else if (iPosition.z < ZMIN + EPSILON || iPosition.z > ZMAX - EPSILON) {
          return mod(0.5*vec2(XMAX - iPosition.x, YMAX - iPosition.y), 1.0);
        } else {
          return vec2(0,0);
        }
      }
      vec3 poolNormal(vec3 iPosition) {
        if (iPosition.x < XMIN + EPSILON || iPosition.x > XMAX - EPSILON) {
          return vec3(-1,0,0) * sign(iPosition.x - 0.5*XMIN - 0.5*XMAX);
        } else if (iPosition.y < YMIN + EPSILON || iPosition.y > YMAX - EPSILON) {
          return vec3(0,-1,0) * sign(iPosition.y - 0.5*YMIN - 0.5*YMAX);
        } else if (iPosition.z < ZMIN + EPSILON || iPosition.z > ZMAX - EPSILON) {
          return vec3(0,0,-1) * sign(iPosition.z - 0.5*ZMIN - 0.5*ZMAX);
        } else {
          return vec3(0);
        }
      }
      vec3 poolColor(vec2 texCoord) {
        //return vec3(texCoord.x, texCoord.y, 0.0);
        return texture2D(poolTexture, texCoord).xyz;
      }
      void main()	{
        vec3 viewDirection = normalize(cameraPosition - vPosition);
        // refraction
        float m = (1.0/(1.33));
        float c1 = dot(vNormal, viewDirection);
        float c2 = sign(c1) * sqrt(1.0 - m*m*(1.0 - c1*c1));
        vec3 refractDirection = m*viewDirection - 1.0*(m*c1 - c2)*vNormal;
        float fresnel =
            0.5 * (1.33*c1 - c2)*(1.33*c1 - c2)/((1.33*c1 + c2)*(1.33*c1 + c2))
          + 0.5 * (c2 - 1.33*c1)*(c2 - 1.33*c1)/((c2 + 1.33*c1)*(c2 + 1.33*c1));
        intersection ib = intersect_box(vec3(XMIN, YMIN, ZMIN), vec3(XMAX, YMAX, ZMAX), vPosition, refractDirection);
        vec3 refractColor;
        if (ib.hit) {
          vec3 iPosition = vPosition + ib.distance * refractDirection;
          vec3 poolNormal = poolNormal(iPosition);
          refractColor = poolColor(poolTextureCoords(iPosition)) * light(poolNormal, iPosition);
          //refractColor = poolColor(poolTextureCoords(iPosition)) * light(poolNormal, iPosition);
        } else {
          refractColor = vec3(1,0,0); // debug
          // refractColor = textureCube(cubeTexture, refractDirection).xyz;
        }
        // reflection
        vec3 reflectDirection = normalize(vPosition - cameraPosition);
        reflectDirection -= 2.0*dot(reflectDirection, vNormal) * vNormal;
        vec3 reflectionColor;
        ib = intersect_box(vec3(XMIN, YMIN, ZMIN), vec3(XMAX, YMAX, ZMAX), vPosition, -reflectDirection);
        if (ib.hit) {
          vec3 iPosition = vPosition - ib.distance * reflectDirection;
          if (iPosition.y >= YMAX - EPSILON) {
            reflectionColor = vec3(0.0);//1.0*textureCube(cubeTexture, vec3(reflectDirection.x, reflectDirection.y, reflectDirection.z)).xyz;
          } else {
            vec3 poolNormal = poolNormal(iPosition);
            reflectionColor = poolColor(poolTextureCoords(iPosition)) * light(poolNormal, iPosition);
          }
        } else {
          reflectionColor = vec3(1,0,0); // debug
        }
        // specular
        vec3 specularColor = vec3(1.0) * max(0.0, pow(dot(vNormal, viewDirection), 2.0));
        float specularIntensity = 0.2;
        // final color
        gl_FragColor = vec4(
          (1.0 - specularIntensity) * fresnel * reflectionColor +
          (1.0 - specularIntensity) * (1.0-fresnel) * refractColor +
          specularIntensity * specularColor, 1.0);
      }
    </script>
    <div id="three"></div>
    <script src="./dist/water-sim.js"></script>
  </body>
</html>
